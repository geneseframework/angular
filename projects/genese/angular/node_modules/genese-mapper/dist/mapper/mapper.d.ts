import { ClassConstructor, TConstructor } from '../models/t-constructor.model';
import { MapperOptions } from '../interfaces/mapper-options.interface';
export declare class Mapper<T> {
    readonly className: string;
    readonly tConstructor: TConstructor<T>;
    /**
     * The constructor takes a Class (ie its constructor) as parameter, or a class name.
     * The tConstructor property is an object with the Type corresponding to this Class
     */
    constructor(classConstructor: ClassConstructor<T> | string, options?: MapperOptions);
    /**
     * The core of the generic mapper
     * If uConstructor is undefined, U equals T and this methodName returns a mapped T object
     * If not, it returns a mapped U object
     * uConstructor is useful for extraction of given fields of a T class object
     */
    create(data: any): Promise<T>;
    /**
     * The core of the generic mapper
     * If uConstructor is undefined, U equals T and this methodName returns a mapped T object
     * If not, it returns a mapped U object
     * uConstructor is useful for extraction of given fields of a T class object
     */
    map(data: any): T;
    /**
     * Receives an array of elements to map (with type T) and returns the array of mapped results (with T type)
     */
    arrayMap(data: any[], tConstructor?: TConstructor<any>): T[];
    /**
     * Check if two objects are both string or number.
     * In this case, returns true.
     */
    _areStringOrNumber(target: any, source: any): boolean;
    /**
     * If source and target are both string or number, we cast source into the target's type and returns it.
     * This methodName adds a tolerance for http requests which returns numbers instead of strings and inversely
     * Caution : params target and source should not be falsy values
     */
    _castStringAndNumbers(target: any, source: any): any;
    /**
     * For a given object with U type (the target model), returns the source object mapped with the U model
     * If source === null, it returns null
     * CAUTION: param "target" can't be undefined
     */
    _diveMap<U>(target: U, source: any): any;
    /**
     * For non-primitive objects, returns source object mapped with the type of the target (U)
     * If source === null, it returns null
     * CAUTION: param "target" can't be undefined
     */
    _mapNotPrimitive<U>(target: U, source: any): any;
    /**
     * When an object haves a field named 'gnIndexableType', that means that this object haves a model like this :
     * {
     *   [key: string]: {
     *       country: string
     *      }
     *   } = {
     *      gnIndexableType: {
     *           country: ''
     *      }
     *  };
     * For each key of gnIndexableType field, this method returns the corresponding mapped object with the target model
     * For example, this method will receive an object like this :
     *
     * gnIndexableType: {
     *      country: ''
     * }
     *
     * and will return something like this :
     *
     * {
     *     fr: {
     *         country: 'France'
     *     },
     *     en: {
     *         country: 'England'
     *     }
     * }
     * Caution: param target should be defined
     */
    _mapIndexableType(target: any, source: any): any;
    _mapIndexableTypeArray(target: any[], source: any): any;
    _mapIndexableTypeObject(target: any, source: any): any;
    /**
     * Map array of objects
     */
    _mapArray(target: any[], source: any[]): any[];
    /**
     * Remove specific genese properties
     */
    _purge(obj: any): any;
    /**
     * If a property of the U class have the decorator @GnRename, this methodName replaces the key of the gnRename http param
     * This methodName is useful when the backend renamed some DTO properties :
     * with @GnRename decorator, you can get values from backend without changing the property name of your T objects in every file
     */
    _rename<U>(uConstructor: TConstructor<U>, data: any): any;
    /**
     * If data object with type U have keys 'gnTranslate', this methodName returns the same object removing gnTranslate key
     * and preserving only the gnTranslate[language] objects
     * Example :
     * if data is like
     * {
     *     gnTranslate: {
     *         fr: {
     *             country: 'Allemagne'
     *         },
     *         en: {
     *             country: 'Germany'
     *         }
     *     }
     * }
     * and if language is 'fr', his methodName will return
     * {
     *     country: 'Allemagne'
     * }
     */
    translate(data: any, language: string): any;
}
export interface IndexableType {
    gnIndexableType: {
        [key: string]: any;
    };
}
