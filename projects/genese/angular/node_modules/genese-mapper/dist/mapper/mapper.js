var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { PRIMITIVES } from '../models/primitive.model';
import { clone, isPrimitive } from '..';
import { AstService } from '../services/ast.service';
import { InitService } from '../services/init.service';
import * as chalk from 'chalk';
import { InstanceService } from './new-instance';
var Mapper = /** @class */ (function () {
    /**
     * The constructor takes a Class (ie its constructor) as parameter, or a class name.
     * The tConstructor property is an object with the Type corresponding to this Class
     */
    function Mapper(classConstructor, options) {
        this.className = undefined;
        this.tConstructor = undefined;
        if (typeof classConstructor === 'string') {
            this.className = classConstructor;
        }
        else {
            this.tConstructor = classConstructor;
            this.className = classConstructor.name;
        }
    }
    /**
     * The core of the generic mapper
     * If uConstructor is undefined, U equals T and this methodName returns a mapped T object
     * If not, it returns a mapped U object
     * uConstructor is useful for extraction of given fields of a T class object
     */
    Mapper.prototype.create = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var classDeclaration;
            return __generator(this, function (_a) {
                InitService.start();
                classDeclaration = AstService.getClassDeclaration(this.className);
                console.log(chalk.greenBright('CSTR FILE PATHHHHHH'), classDeclaration === null || classDeclaration === void 0 ? void 0 : classDeclaration.getName());
                return [2 /*return*/, InstanceService.newInstance(data, this.className, classDeclaration)];
            });
        });
    };
    /**
     * The core of the generic mapper
     * If uConstructor is undefined, U equals T and this methodName returns a mapped T object
     * If not, it returns a mapped U object
     * uConstructor is useful for extraction of given fields of a T class object
     */
    Mapper.prototype.map = function (data) {
        var target = new this.tConstructor();
        if (!data) {
            return target;
        }
        if (this.tConstructor.hasOwnProperty('gnRename')) {
            data = this._rename(this.tConstructor, data);
        }
        return Object.assign(target, this._diveMap(target, data));
    };
    /**
     * Receives an array of elements to map (with type T) and returns the array of mapped results (with T type)
     */
    Mapper.prototype.arrayMap = function (data, tConstructor) {
        var _this = this;
        if (tConstructor === void 0) { tConstructor = this.tConstructor; }
        if (data === null) {
            return null;
        }
        if (!Array.isArray(data)) {
            return [];
        }
        var results = [];
        if (PRIMITIVES.includes(tConstructor.name)) {
            data.forEach(function (e) {
                if (typeof e === tConstructor.name.toLowerCase()) {
                    results.push(e);
                }
                else if (tConstructor.name === 'String' && typeof e === 'number') {
                    results.push(e.toString());
                }
                else if (tConstructor.name === 'Number' && typeof e === 'string' && !isNaN(Number(e))) {
                    results.push(+e);
                }
                else if (e === null) {
                    results.push(null);
                }
            });
        }
        else {
            data.forEach(function (e) {
                results.push(_this.create(e));
            });
        }
        return results;
    };
    // --------------------------------------------------
    //                 INTERNAL METHODS
    // --------------------------------------------------
    /**
     * Check if two objects are both string or number.
     * In this case, returns true.
     */
    Mapper.prototype._areStringOrNumber = function (target, source) {
        return ((typeof target === 'string' || typeof target === 'number') && (typeof source === 'number' || typeof source === 'string'));
    };
    /**
     * If source and target are both string or number, we cast source into the target's type and returns it.
     * This methodName adds a tolerance for http requests which returns numbers instead of strings and inversely
     * Caution : params target and source should not be falsy values
     */
    Mapper.prototype._castStringAndNumbers = function (target, source) {
        if ((typeof target !== 'string' && typeof target !== 'number') || source === undefined) {
            console.warn('Genese _castStringAndNumbers : source or target undefined');
            return undefined;
        }
        else if (source === null) {
            return null;
        }
        else if (typeof target === 'string' && (typeof source === 'number' || typeof source === 'string')) {
            return source.toString();
        }
        else if (typeof target === 'number' && typeof source === 'number') {
            return source;
        }
        else if (typeof target === 'number' && typeof source === 'string') {
            return isNaN(Number(source)) ? target : +source;
        }
        else {
            console.warn('Genese _castStringAndNumbers : impossible to cast this elements');
            return undefined;
        }
    };
    /**
     * For a given object with U type (the target model), returns the source object mapped with the U model
     * If source === null, it returns null
     * CAUTION: param "target" can't be undefined
     */
    Mapper.prototype._diveMap = function (target, source) {
        if (source === undefined) {
            return target;
        }
        else if (source === null) {
            return source;
        }
        else {
            if (isPrimitive(target)) {
                if (isPrimitive(source)) {
                    if (this._areStringOrNumber(target, source)) {
                        return this._castStringAndNumbers(target, source);
                    }
                    else {
                        return (typeof source === 'boolean' && typeof target === 'boolean') ? source : target;
                    }
                }
                else {
                    return target;
                }
            }
            else {
                return this._mapNotPrimitive(target, source);
            }
        }
    };
    /**
     * For non-primitive objects, returns source object mapped with the type of the target (U)
     * If source === null, it returns null
     * CAUTION: param "target" can't be undefined
     */
    Mapper.prototype._mapNotPrimitive = function (target, source) {
        if (source === undefined) {
            return target;
        }
        else if (source === null) {
            return null;
        }
        else {
            var cloneTarget = Object.assign({}, target);
            for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
                var key = _a[_i];
                if (key === 'gnIndexableType') {
                    cloneTarget = this._mapIndexableType(target, source);
                }
                else {
                    if (target[key] !== undefined) {
                        if (source[key] === null) {
                            cloneTarget[key] = null;
                        }
                        else if (source[key] === undefined) {
                            cloneTarget[key] = this._purge(target[key]);
                        }
                        else {
                            if (Array.isArray(target[key])) {
                                cloneTarget[key] = Array.isArray(source[key])
                                    ? this._mapArray(target[key], source[key])
                                    : cloneTarget[key];
                            }
                            else {
                                if (this._areStringOrNumber(target[key], source[key])) {
                                    cloneTarget[key] = this._castStringAndNumbers(target[key], source[key]);
                                }
                                else {
                                    cloneTarget[key] = this._diveMap(target[key], source[key]);
                                }
                            }
                        }
                    }
                    else {
                        return source;
                    }
                }
            }
            return cloneTarget;
        }
    };
    /**
     * When an object haves a field named 'gnIndexableType', that means that this object haves a model like this :
     * {
     *   [key: string]: {
     *       country: string
     *      }
     *   } = {
     *      gnIndexableType: {
     *           country: ''
     *      }
     *  };
     * For each key of gnIndexableType field, this method returns the corresponding mapped object with the target model
     * For example, this method will receive an object like this :
     *
     * gnIndexableType: {
     *      country: ''
     * }
     *
     * and will return something like this :
     *
     * {
     *     fr: {
     *         country: 'France'
     *     },
     *     en: {
     *         country: 'England'
     *     }
     * }
     * Caution: param target should be defined
     */
    Mapper.prototype._mapIndexableType = function (target, source) {
        if (target === undefined || target.gnIndexableType === undefined) {
            console.warn('Impossible to map indexable types with undefined target.');
            return undefined;
        }
        if (source === undefined) {
            return target;
        }
        if (source === null) {
            return null;
        }
        return Array.isArray(target.gnIndexableType) && target.gnIndexableType.length > 0
            ? this._mapIndexableTypeArray(target.gnIndexableType[0], source)
            : Object.assign({}, this._mapIndexableTypeObject(target.gnIndexableType, source));
    };
    Mapper.prototype._mapIndexableTypeArray = function (target, source) {
        var _a, _b;
        var mappedObject = {};
        for (var _i = 0, _c = Object.keys(source); _i < _c.length; _i++) {
            var key = _c[_i];
            var deepMapped = this._diveMap((_a = {}, _a[key] = [target], _a), source);
            Object.assign(mappedObject, (_b = {}, _b[key] = deepMapped[key], _b));
        }
        return mappedObject;
    };
    Mapper.prototype._mapIndexableTypeObject = function (target, source) {
        var _a;
        var mappedObject = {};
        for (var _i = 0, _b = Object.keys(source); _i < _b.length; _i++) {
            var key = _b[_i];
            Object.assign(mappedObject, (_a = {}, _a[key] = this._diveMap(target, source[key]), _a));
        }
        return mappedObject;
    };
    /**
     * Map array of objects
     */
    Mapper.prototype._mapArray = function (target, source) {
        if (source === null) {
            return null;
        }
        if (source === undefined || !Array.isArray(source) || (Array.isArray(target) && !Array.isArray(source))) {
            return target;
        }
        if (!Array.isArray(target) || target.length === 0) {
            console.warn('Impossible to map array of objects with undefined or empty array');
            return undefined;
        }
        var arrayOfObjects = [];
        var model = clone(target[0]);
        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
            var element = source_1[_i];
            var mappedElement = void 0;
            if (Array.isArray(model) && Array.isArray(element)) {
                mappedElement = this._mapArray(model, element);
            }
            else if (Array.isArray(model) && !Array.isArray(element) && !!element) {
                return target;
            }
            else {
                mappedElement = this._diveMap(model, element);
            }
            arrayOfObjects.push(mappedElement);
        }
        return arrayOfObjects;
    };
    /**
     * Remove specific genese properties
     */
    Mapper.prototype._purge = function (obj) {
        if (!obj) {
            return obj;
        }
        delete obj.gnIndexableType;
        return obj;
    };
    /**
     * If a property of the U class have the decorator @GnRename, this methodName replaces the key of the gnRename http param
     * This methodName is useful when the backend renamed some DTO properties :
     * with @GnRename decorator, you can get values from backend without changing the property name of your T objects in every file
     */
    Mapper.prototype._rename = function (uConstructor, data) {
        var constr = uConstructor;
        Object.keys(constr.gnRename).map(function (oldKey) {
            var newKey = constr.gnRename[oldKey];
            if (data[newKey]) {
                data[oldKey] = data[newKey];
                delete data[newKey];
            }
        });
        return data;
    };
    /**
     * If data object with type U have keys 'gnTranslate', this methodName returns the same object removing gnTranslate key
     * and preserving only the gnTranslate[language] objects
     * Example :
     * if data is like
     * {
     *     gnTranslate: {
     *         fr: {
     *             country: 'Allemagne'
     *         },
     *         en: {
     *             country: 'Germany'
     *         }
     *     }
     * }
     * and if language is 'fr', his methodName will return
     * {
     *     country: 'Allemagne'
     * }
     */
    Mapper.prototype.translate = function (data, language) {
        var _this = this;
        if (!data || !language) {
            console.error('No data or no language : impossible to translate element');
            return undefined;
        }
        else {
            var result_1 = clone(data);
            Object.keys(result_1).map(function (key) {
                if (key === 'gnTranslate') {
                    Object.assign(result_1, result_1.gnTranslate[language]);
                    delete result_1.gnTranslate;
                }
                else {
                    if (typeof result_1[key] === 'object') {
                        var copy = clone(result_1[key]);
                        result_1[key] = _this.translate(copy, language);
                    }
                }
            });
            return result_1;
        }
    };
    return Mapper;
}());
export { Mapper };
